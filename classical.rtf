import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Set non-interactive backend
import matplotlib.pyplot as plt
import os

# Print current working directory for debugging
print("Current working directory:", os.getcwd())

# Fixed parameters
K = 40  # Strike price
r = 0.06  # Risk-free interest rate
sigma = 0.2  # Volatility
alpha = 1.0  # SOR parameter

# Grid parameters
S_max = 80  # Maximum asset price
S_min = 0  # Minimum asset price
M = 80  # Number of spatial steps
N = 1000  # Number of time steps

def payoff_put(S, K):
    """Payoff function for put option"""
    return np.maximum(K - S, 0)

def crank_nicolson_american_put(S_max, K, r, sigma, T, M, N, alpha, tol=1e-6, max_iter=1000):
    """
    Solve American put option using Crank-Nicolson method and SOR algorithm
   
    Parameters:
    S_max: Maximum asset price
    K: Strike price
    r: Risk-free interest rate
    sigma: Volatility
    T: Time to maturity
    M: Number of spatial grid points
    N: Number of time grid points
    alpha: SOR relaxation parameter
    tol: Convergence tolerance
    max_iter: Maximum number of iterations
    """
    # Grid setup
    dS = S_max / M
    dt = T / N
    S = np.linspace(0, S_max, M+1)
   
    # Initialize option value (at maturity)
    V = payoff_put(S, K)
    V_new = V.copy()
   
    # Boundary conditions
    # When S=0, American put value is K due to immediate exercise
    # When S=S_max, put option value is approximately 0
   
    # Crank-Nicolson coefficients
    for n in range(N-1, -1, -1):
        t = n * dt
       
        # Construct tridiagonal matrix coefficients
        a = np.zeros(M+1)
        b = np.zeros(M+1)
        c = np.zeros(M+1)
        d = np.zeros(M+1)
       
        for i in range(1, M):
            Si = i * dS
           
            # Crank-Nicolson scheme coefficients
            alpha_i = 0.25 * dt * (sigma**2 * i**2 - r * i)
            beta_i = -0.5 * dt * (sigma**2 * i**2 + r)
            gamma_i = 0.25 * dt * (sigma**2 * i**2 + r * i)
           
            a[i] = -alpha_i
            b[i] = 1 - beta_i
            c[i] = -gamma_i
           
            # Right-hand side
            d[i] = alpha_i * V[i-1] + (1 + beta_i) * V[i] + gamma_i * V[i+1]
       
        # Boundary conditions
        b[0] = 1
        d[0] = K  # Set to K for American put (immediate exercise at S=0)
       
        b[M] = 1
        d[M] = 0
       
        # SOR iteration (considering early exercise constraint for American option)
        V_old = V.copy()
        for iter_count in range(max_iter):
            V_prev = V_new.copy()
           
            # Boundaries
            V_new[0] = K  # Ensure American put value at S=0 is K
            V_new[M] = d[M]
           
            # SOR iteration
            for i in range(1, M):
                # Gauss-Seidel update
                gs_value = (d[i] - a[i] * V_new[i-1] - c[i] * V_prev[i+1]) / b[i]
               
                # SOR update
                V_new[i] = (1 - alpha) * V_prev[i] + alpha * gs_value
               
                # American option constraint: Option value cannot be less than intrinsic value
                payoff = K - i * dS
                V_new[i] = max(V_new[i], payoff)
           
            # Check convergence
            if np.max(np.abs(V_new - V_prev)) < tol:
                break
       
        V = V_new.copy()
   
    return S, V

def crank_nicolson_european_put(S_max, K, r, sigma, T, M, N):
    """
    Solve European put option using Crank-Nicolson method
    """
    # Grid setup
    dS = S_max / M
    dt = T / N
    S = np.linspace(0, S_max, M+1)
   
    # Initialize option value
    V = payoff_put(S, K)
   
    # Crank-Nicolson iteration
    for n in range(N-1, -1, -1):
        t = n * dt
       
        # Construct tridiagonal matrix
        A = np.zeros((M+1, M+1))
        b = np.zeros(M+1)
       
        for i in range(1, M):
            Si = i * dS
           
            alpha_i = 0.25 * dt * (sigma**2 * i**2 - r * i)
            beta_i = -0.5 * dt * (sigma**2 * i**2 + r)
            gamma_i = 0.25 * dt * (sigma**2 * i**2 + r * i)
           
            A[i, i-1] = -alpha_i
            A[i, i] = 1 - beta_i
            A[i, i+1] = -gamma_i
           
            b[i] = alpha_i * V[i-1] + (1 + beta_i) * V[i] + gamma_i * V[i+1]
       
        # Boundary conditions
        A[0, 0] = 1
        b[0] = K * np.exp(-r * (T - t))
       
        A[M, M] = 1
        b[M] = 0
       
        V = np.linalg.solve(A, b)
   
    return S, V

# Calculate results
print("="*80)
print("American Put Option Pricing - Crank-Nicolson Method + SOR Algorithm")
print("="*80)
print(f"\nParameter Settings:")
print(f"  Strike Price K = {K}")
print(f"  Risk-free Interest Rate r = {r}")
print(f"  Volatility σ = {sigma}")
print(f"  SOR Parameter α = {alpha}")
print(f"  Number of Spatial Steps M = {M}")
print(f"  Number of Time Steps N = {N}")

# Specified asset price points
asset_prices = [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80]

# Calculate results for T=3 months and T=6 months
results = []
data_for_plot = {}

for T_months in [3, 6]:
    T = T_months / 12  # Convert to years
   
    print(f"\n{'='*80}")
    print(f"Time to Maturity T = {T_months} months ({T} years)")
    print(f"{'='*80}")
   
    # Solve American option
    S_american, V_american = crank_nicolson_american_put(S_max, K, r, sigma, T, M, N, alpha)
   
    # Solve European option
    S_european, V_european = crank_nicolson_european_put(S_max, K, r, sigma, T, M, N)
   
    # Store data for plotting
    data_for_plot[T_months] = {
        'S': S_american,
        'V_american': V_american,
        'V_european': V_european,
        'Payoff': payoff_put(S_american, K)
    }
   
    # Debug: Check data shapes
    print(f"T={T_months} months: S shape={S_american.shape}, V_american shape={V_american.shape}, V_european shape={V_european.shape}")
   
    # Interpolate for specified price points
    for S_target in asset_prices:
        idx = int(S_target / (S_max / M))
        payoff = max(K - S_target, 0)
       
        result = {
            'T (months)': T_months,
            'Asset Price': S_target,
            'Payoff Value': payoff,
            'European Put': V_european[idx],
            'American Put': V_american[idx]
        }
        results.append(result)

# Create DataFrame
df = pd.DataFrame(results)

# Display results for T=3 months and T=6 months separately
print("\n" + "="*80)
print("Results Summary Table")
print("="*80)

for T_months in [3, 6]:
    df_t = df[df['T (months)'] == T_months]
    print(f"\nTime to Maturity T = {T_months} months:")
    print("-"*80)
    print(df_t.to_string(index=False, float_format=lambda x: f'{x:.6f}'))

# Full table
print("\n" + "="*80)
print("Complete Results Table")
print("="*80)
print(df.to_string(index=False, float_format=lambda x: f'{x:.6f}'))

print("\nNotes:")
print("- Payoff Value: Intrinsic value of the put option = max(K - S, 0)")
print("- European Put: European put option price")
print("- American Put: American put option price")
print("- American option price ≥ European option price (due to early exercise right)")
print("- American option price ≥ Payoff Value (option value not less than intrinsic value)")

# Plotting
print("\nGenerating and saving plot...")
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

for idx, T_months in enumerate([3, 6]):
    ax = axes[idx]
    data = data_for_plot[T_months]
    S = data['S']
    V_american = data['V_american']
    V_european = data['V_european']
    Payoff = data['Payoff']
   
    # Plot curves
    ax.plot(S, Payoff, 'k--', label='Payoff', linewidth=1.5)
    ax.plot(S, V_european, 'b-', label='European Put', linewidth=2)
    ax.plot(S, V_american, 'r-', label='American Put', linewidth=2)
   
    # Find approximate free boundary (where V_american is tangent to Payoff)
    tol = 1e-4
    S_f = None
    V_f = None
    # Iterate from right to left to find the tangency point
    for i in range(len(S)-1, -1, -1):
        if S[i] < K and abs(V_american[i] - Payoff[i]) < tol:
            # Check if the American put is above payoff to the right (indicating tangency)
            if i < len(S)-1 and V_american[i+1] > Payoff[i+1] + tol:
                S_f = S[i]
                V_f = V_american[i]
                break
    if S_f is None:
        # Fallback: Find the point where V_american is closest to Payoff but above it to the right
        diff = V_american - Payoff
        valid_indices = np.where((S < K) & (V_american >= Payoff))[0]
        if len(valid_indices) > 0:
            # Select the largest S where V_american ≈ Payoff
            for i in valid_indices[::-1]:
                if i < len(S)-1 and V_american[i+1] > Payoff[i+1] + tol:
                    S_f = S[i]
                    V_f = V_american[i]
                    break
   
    # Annotate free boundary
    if S_f is not None:
        ax.annotate(f'Free Boundary\nS ≈ {S_f:.2f}', xy=(S_f, V_f),
                    xytext=(S_f + 5, V_f + 5),
                    arrowprops=dict(facecolor='green', shrink=0.05, headwidth=8),
                    fontsize=10, color='green')
        print(f"T={T_months} months: Free boundary at S ≈ {S_f:.2f}")
   
    ax.set_title(f'T = {T_months} months')
    ax.set_xlabel('Asset Price (S)')
    ax.set_ylabel('Option Value')
    ax.legend()
    ax.grid(True)

plt.tight_layout()
print("Saving plot to option_pricing_plot.png")
plt.savefig('option_pricing_plot.png')
plt.close()
print("Plot saved successfully")
